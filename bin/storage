#!/usr/bin/env bash

set -euo pipefail

# Convenience functions
info () {
  printf "\r[ \033[00;34m..\033[0m ] $1\n"
}

success () {
  printf "\r\033[2K[ \033[00;32mOK\033[0m ] $1\n"
}

fail () {
  printf "\r\033[2K[\033[0;31mFAIL\033[0m] $1\n"
}

check_binary () {
  which $1 > /dev/null 2>&1
  status=$?
  if [ $status -eq 0 ]; then
    success "Found binary ${1} in PATH"
  else
    fail "No valid binary for ${1} found in PATH. Please correct your installation"
    exit 1
  fi
}



# Setup checks
set +e

info "Checking for psql binary..."
check_binary "psql"

set -e


# TODOs
#   - command line args:
#     - user
#     - password
#     - hostname
#     - force
#     - dryrun
#     - namespace
# 
#   - get it out of bash

#  Test database connection
pg_isready -d dstk -h 127.0.0.1 -p 5432 -U postgres -P "${POSTGRES_PWD}"

# Enumerate patches
SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd -P)
patches=$(find "${SCRIPT_DIR}../src/postgres/patches" -type f -name '*.sql' | sort)

for patch in "${patches[@]}"; do
  echo "${patch}"
done